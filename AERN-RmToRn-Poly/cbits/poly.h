#include <stdint.h>

/* The following are provided for better code readability: */
typedef void * Coeff; // pointer to undisclosed Haskell type t
typedef void * UnaryOp; // pointer to Haskell type t -> t
typedef void * BinaryOp; // pointer to Haskell type t -> t -> t
typedef void * ConversionOp; // pointer to Haskell type t1 -> t2

typedef uint32_t Var;
typedef uint32_t Power;
typedef uint32_t Size;

// to be imported from a header generated by ghc:
Coeff
evaluateUnary(UnaryOp op, Coeff param);
Coeff
evaluateBinary(BinaryOp op, Coeff param1, Coeff param2);

/* A polynomial term: */
typedef struct TERM
{
  Power * powers;
  Coeff coeff;
} Term;

/* A polynomial: */
typedef struct POLY
{
  Var maxArity; // nominal number of variables
  Size maxSize; // maximal number of non-constant terms
  Size psize; // actual number of non-constant terms
  Coeff constTerm;
  Term * terms;
} Poly;

Poly *
newConstPoly(Coeff c, Var maxArity, Size maxSize);

typedef void * Value; // A Haskell value passed via StablePtr

/*
 * Interpret the terms as Chebyshev polynomials and evaluate them for the
 * given values assigned to variables using the given addition and multiplication
 * Haskell operations.
 */
Value
evalAtPtChebBasis(Poly *, Value *, Value, BinaryOp, BinaryOp, BinaryOp, ConversionOp);

/*
 * preconditions:
 * res has to point to an allocated polynomial with initialised maxArity and maxSize;
 * res has to have maxArity larger than p;
 * res has to have maxSize not smaller than p;
 */
void
incrementArity(Poly * res, Poly *p, Var * old2new);

/* References to operations provided by Haskell: */
typedef struct OPS
{
  Coeff zero;
  Coeff one;
  UnaryOp absUp;
  UnaryOp absDn;
  BinaryOp plusUp;
  BinaryOp plusDn;
  BinaryOp timesUp;
  BinaryOp timesDn;
} Ops;

/*
 * preconditions:
 * 0 <= var && var < maxArity
 * 0 < maxSize
 */
Poly *
newProjectionPoly(Ops * ops, Var var, Var maxArity, Size maxSize);

/*
 * The following operations expect all polynomial parameters and result space to
 * have matching maxArities and maxSizes.
 */

void
addUp(Ops * ops, Poly *res, Poly * p1, Poly * p2);

